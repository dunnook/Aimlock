local rs = game:GetService("ReplicatedStorage")
local remote
local towerFolder
local upgradesFolder
local placeHolder
local towers = {}
local upgrades = {}
for i, v in next, rs:GetDescendants() do
    if table.find({"Towers"}, v.Name) and v:IsA("Folder") then
        towerFolder = v
    end
    if table.find({"Upgrades"}, v.Name) and v:IsA("Folder") then
        upgradesFolder = v
    end
    if table.find({"SpawnTower"}, v.Name) and (v:IsA("RemoteEvent") or v:IsA("RemoteFunction")) then
        remote = v
    end
end
if towerFolder == nil or upgradesFolder == nil or remote == nil then
    warn("Need manual or script no work")
    return
end
local modelCount_towerfolder = 0
local folderCount_towerfolder = 0
for i, v in next, towerFolder:GetChildren() do
    if v:IsA("Model") then
        modelCount_towerfolder += 1
    elseif v:IsA("Folder") then
        folderCount_towerfolder += 1
    end
end
local modelCount_upgradefolder = 0
local folderCount_upgradefolder = 0
for i, v in next, upgradesFolder:GetChildren() do
    if v:IsA("Model") then
        modelCount_upgradefolder += 1
    elseif v:IsA("Folder") then
        folderCount_upgradefolder += 1
    end
end
if modelCount_towerfolder < folderCount_towerfolder then
    warn("Towers are folders")
    return
end
if modelCount_upgradefolder < folderCount_upgradefolder then
    warn("Upgrade Towers are folders")
    return
end
function findCheapest()
    local cheapest = nil
    local price = math.huge
    for i, v in next, towerFolder:GetChildren() do
        if v:IsA("Model") then
            local priceInstance = v:FindFirstChild("Price", true)
            if priceInstance then
                if priceInstance.Value < price then
                    cheapest = v
                    price = priceInstance.Value
                end
            end
        end
    end
    return cheapest
end
local default = findCheapest()
if not default then
    warn("Set default manually")
    return
end
for i, v in next, towerFolder:GetChildren() do
    if v:IsA("Model") then
        local str = v.Name
        if v:FindFirstChild("Price", true) then
            str = str..", "..v:FindFirstChild("Price", true).Value
        end
        table.insert(towers, str)
    end
end
for i, v in next, upgradesFolder:GetChildren() do
    if v:IsA("Model") then
        local str = v.Name
        if v:FindFirstChild("Price", true) then
            str = str..", "..v:FindFirstChild("Price", true).Value
        end
        table.insert(upgrades, str)
    end
end
local args = {}
local upgradeArgs = {}
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/shlexware/Rayfield/main/source'))()
local Window = Rayfield:CreateWindow({
    Name = "Rayfield Example Window",
    LoadingTitle = "Rayfield Interface Suite",
    LoadingSubtitle = "by Sirius",
    ConfigurationSaving = {
        Enabled = false   ,
        FolderName = nil, -- Create a custom folder for your hub/game
        FileName = "Big Hub"
    },
    Discord = {
        Enabled = false,
        Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD.
        RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
        Title = "Sirius Hub",
        Subtitle = "Key System",
        Note = "Join the discord (discord.gg/sirius)",
        FileName = "SiriusKey",
        SaveKey = true,
        GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
        Key = "Hello"
    }
})
local Tab = Window:CreateTab("Tab Example", 4483362458) -- Title, Image

local Dropdown1 = Tab:CreateDropdown({
    Name = "Choose tower (Upgrade)",
    Options = upgrades,
    CurrentOption = "None",
    Flag = "Dropdown1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Option)
        local towerName = string.split(Option[1], ",")[1]
        upgradeArgs[1] = towerName or tostring(Option[1])
    end,
})

local Dropdown2 = Tab:CreateDropdown({
    Name = "Choose tower",
    Options = towers,
    CurrentOption = "None",
    Flag = "Dropdown2", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Option)
        local towerName = string.split(Option[1], ",")[1]
        args[1] = towerName or tostring(Option[1])
    end,
})
local Button1 = Tab:CreateButton({
    Name = "Spawn Tower (Upgrade) (May need money)",
    Callback = function()
        upgradeArgs[2] = game:GetService("Players").LocalPlayer.Character.PrimaryPart.CFrame
		local editArgs = {
			[1] = default,
            [2] = game:GetService("Players").LocalPlayer.Character.PrimaryPart.CFrame,
		}
        if remote.ClassName == "RemoteFunction" then
            placeHolder = remote:InvokeServer(unpack(editArgs))
			upgradeArgs[3] = placeHolder
			remote:InvokeServer(unpack(upgradeArgs))
        elseif remote.ClassName == "RemoteEvent" then
            placeHolder = remote:FireServer(unpack(editArgs))
            upgradeArgs[3] = placeHolder
            remote:FireServer(unpack(upgradeArgs))
        else
            print("Wrong path")
        end
    end,
 })
local Button2 = Tab:CreateButton({
Name = "Spawn Tower (May need money)",
Callback = function()
	args[2] = game:GetService("Players").LocalPlayer.Character.PrimaryPart.CFrame
	if remote.ClassName == "RemoteFunction" then
        remote:InvokeServer(unpack(args))
    elseif remote.ClassName == "RemoteEvent" then
        remote:FireServer(unpack(args))
    else
        print("Wrong path")
    end
end,
})
